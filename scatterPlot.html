<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Graph Library</title>
    <link href="graph.css?" rel="stylesheet">
    <script>

      class Graph {

          constructor(props) {
            // GRAPH COMPONENTS
            this.container = props.container;
            this.randId = Math.floor(Math.random() * 10000);
            this.width = props.width && props.width >= 200 ? props.width : 200;
            this.height = props.height && props.height >= 200 ? props.height : 200;
            this.xIntervals = props.xIntervals ? props.xIntervals : 1;
            this.yIntervals = props.yIntervals ? props.yIntervals : 1;
            this.minXValue = props.minXValue ? props.minXValue : 0;
            this.maxXValue = props.maxXValue ? props.maxXValue : 100;
            this.minYValue = props.minYValue ? props.minYValue : 0;
            this.maxYValue = props.maxYValue ? props.maxYValue : 100;
            this.labels = props.labels ? props.labels : [];
            this.title = props.title ? props.title : "";
            this.xLabel = props.xLabel  ? props.xLabel : "";
            this.yLabel = props.yLabel  ? props.yLabel : "";
            this.values = props.values ? props.values : [];
            this.trendLine = props.trendLine ? props.trendLine : false;
            this.intervalGuides = props.intervalGuides ? props.intervalGuides : false;
            this.valueGuides = props.valueGuides ? props.valueGuides : false;
            this.showValues = props.showValues ? props.showValues : false;
            this.disableZoom = props.disableZoom;
            this.graphKey = props.graphKey ? props.graphKey : false;
            this.graphKeyTitle = props.graphKeyTitle ? props.graphKeyTitle : "Graph Key";
            this.graphKeyValues = [];
            this.barColorSet = [];
            this.connected = props.connected ? props.connected : false;
            this.animate = props.animate ? props.animate : false;
            this.data = props.data ? props.data : false;
            this.points = [];
            this.allpoints = [];
            if(this.data) {
              this.barColorSet = [];
              for (let name in this.data) {
                this.graphKeyValues.push(name);
                if (this.data[name].color) {
                  this.barColorSet.push(this.data[name].color);
                } else if (this.barColorSet.length > 0){
                  this.barColorSet.push("black");
                }
                let points = [];
                this.data[name].points.forEach((point) => {
                  points.push(point);
                  this.allpoints.push(point);
                });
                points.sort(function(a,b) { return a.x - b.x });
                this.points.push(points);
              }
              this.allpoints.sort(function(a,b) { return a.x - b.x });
            }
            this.barColorSet = this.barColorSet == "" ? ["#222222","#555555","#999999","#b2b2b2","#cccccc"] : this.barColorSet;

            // GRAPH TYPE
            if (props.type === "scatter") {
              this.container.innerHTML = this.generateScatterPlot();
              this.container.style.width = this.width + 100 + "px";
              this.container.style.height = this.height + 200 + "px";
              document.getElementById("graphDataDiv" + this.randId).addEventListener("mousedown", (e) => { startZoom(e, this.randId) }, false);
              document.getElementById("graphDataDiv" + this.randId).addEventListener("mousemove", (e) => { setZoom(e, this.randId) }, false);
              document.getElementById("graphDataDiv" + this.randId).addEventListener("mouseup", () => { zoom(this, this.randId) }, false);
            }
          }

          generateScatterPlot() {
            var topOfGraphHTML = "";
            var intervalsHTML = "";
            var zoomHTML = "";
            var intervalGuidesHTML = "";
            var graphHTML = "";
            var bottomOfGraphHTML = "";
            topOfGraphHTML += "<div class='mainGraphContainer' style=width:" + ((80 + this.width) + 4) + "px;>";

            //TITLE
            if(this.title != "") {
              topOfGraphHTML += "<div class='titleContainer'>" + this.title + "</div>";
            }

            // GRAPH KEY
            if(this.graphKey) {
              topOfGraphHTML += "<div class='graphKeyContainer' style='width:" + (this.width + 4) + "px;'>" + this.graphKeyTitle + ":";
              topOfGraphHTML += "<div style=width:100%;position;relative;>";
              this.graphKeyValues.map( (value, key) => {
                topOfGraphHTML += "<div class='keySection'><div class='keySquare' onMouseOver=showData("+key+","+this.randId+") onMouseOut=showAllData("+this.randId+") style=background:" + this.barColorSet[key] + "></div><div class='keyText'>" + value + "</div></div>";
              });
              topOfGraphHTML += "</div>";
              topOfGraphHTML +="</div>";
            }

            // INTERVALS
            intervalsHTML += "<div class='yIntervalsContainer' style='height:" + this.height + "px;'>";
            intervalsHTML += "<div class='yLabel' style='width:"+this.height+"px;'>" + this.yLabel + "</div>";
            var bottompx = -11;
            for (let i = 0; i <= this.yIntervals; i ++) {
              intervalsHTML += "<div class='yInterval' style=bottom:" +  (i == 0 ? -6 : bottompx) + "px;>" + parseFloat((i * ((this.maxYValue - this.minYValue) / this.yIntervals)) + this.minYValue).toFixed(2).replace(".00","") + "</div>";
              bottompx += (this.height / this.yIntervals);
            }
            intervalsHTML += "</div>";

            // GRAPH DATA DIV
            zoomHTML += "<div id='graphDataDiv" + this.randId + "' class='graphDataContainer' style='width:" + this.width + "px;height:" + this.height + "px;'>";
            // ZOOM FUNCTIONALITY
            if (!this.disableZoom) {
              zoomHTML += "<div style='display:none;top:0px;left:0px;' id='"+this.randId+"startZoom' class='startZoom'><div style='bottom:0px;top:0px;left:4px;' id='"+this.randId+"rightBounds' class='rightBounds'><div style='bottom:-4px;left:-4px;top:;' id='"+this.randId+"innerLeftSquare' class='leftSquare'></div></div><div style='left:0px;right:0px;top:4px;' id='"+this.randId+"topBounds' class='topBounds'></div></div>";
              zoomHTML += "<div style='display:none;top:0px;left:0px;' id='"+this.randId+"setZoom' class='setZoom'><div style='bottom:0px;top:0px;left:4px;' id='"+this.randId+"leftBounds' class='leftBounds'><div style='top:-4px;right:-4px;bottom:;' id='"+this.randId+"innerRightSquare' class='rightSquare'></div></div><div style='left:0px;right:0px;top:4px;' id='"+this.randId+"bottomBounds' class='bottomBounds'></div></div>";
              zoomHTML += "<div style='top:0px;left:0px;' id='"+this.randId+"topBoundsBox' class='topBoundsBox'></div>";
              zoomHTML += "<div style='bottom:0px;left:0px;' id='"+this.randId+"bottomBoundsBox' class='bottomBoundsBox'></div>";
              zoomHTML += "<div style='top:0px;left:0px;' id='"+this.randId+"leftBoundsBox' class='leftBoundsBox'></div>";
              zoomHTML += "<div style='top:0px;right:0px;' id='"+this.randId+"rightBoundsBox' class='rightBoundsBox'></div>";
              if (this.zoomed) {
                zoomHTML += "<div id='"+this.randId+"zoomOut' class='zoomOut'><div class='zoomOutMagnifyingGlassBG '><div class='zoomOutMagnifyingGlassInnerBG'><div class='zoomOutMagnifyingGlassLine'></div></div></div><div class='zoomOutMagnifyingGlassHandle'></div></div>";
              }
            }

            // INTERVAL GUIDES
            if (this.intervalGuides) {
              let bottompx = -2;
                for (let i = 0; i <= this.yIntervals; i ++) {
                  if (i > 0 && i != this.yIntervals) {
                    intervalGuidesHTML += "<div class='yIntervalGuide' style='bottom:" + bottompx + "px;'></div>";
                }
                bottompx += (this.height / this.yIntervals);
              }
              let leftpx = (this.width / this.xIntervals);
              for (let i = 0; i <= this.xIntervals; i ++) {
                if (i > 0 && i != this.xIntervals) {
                  intervalGuidesHTML += "<div class='xIntervalGuide' style='left:" + leftpx + "px;'></div>";
                  leftpx += (this.width / this.xIntervals);
                }
              }
            }

            if (this.minYValue < 0) {
                let zeroLineTop = ((0 - this.minYValue) / (this.maxYValue - this.minYValue) * this.height);
                intervalGuidesHTML += "<div class='zeroLineY' style='bottom:"+zeroLineTop+"px;'></div>";
            }
            if (this.minXValue < 0) {
                let zeroLineLeft = ((0 - this.minXValue) / (this.maxXValue - this.minXValue) * this.width);
                intervalGuidesHTML += "<div class='zeroLineX' style='left:" + zeroLineLeft + "px;'></div>";
            }

            // PLOTTING THE POINTS
            var uniqueIndex = 0;
            for (let index in this.points) {

              for(let cIndex in this.points[index]) {
                let x = this.points[index][cIndex].x;
                let y = this.points[index][cIndex].y;
                let left = (this.width - (((x - this.minXValue) / (this.maxXValue - this.minXValue)) * this.width));
                let marginTop = (this.height - (((y - this.minYValue) / (this.maxYValue - this.minYValue)) * this.height));

                graphHTML += "<div class='guide"+this.randId+"Line"+uniqueIndex+" guideLineX' onMouseOver=lineOver(" + uniqueIndex + ","+this.randId+") onMouseOut=lineOut(" + uniqueIndex + ","+this.randId+") onClick=showLine(" + uniqueIndex + ","+this.randId+") style='display:none;top:" + (marginTop + 1)  + "px;'></div>";
                graphHTML += "<div class='guide"+this.randId+"Line"+uniqueIndex+" guideLineY' onMouseOver=lineOver(" + uniqueIndex + ","+this.randId+") onMouseOut=lineOut(" + uniqueIndex + ","+this.randId+") onClick=showLine(" + uniqueIndex + ","+this.randId+") style='display:none;left:" + (this.width - left) + "px;'></div>";
                graphHTML += "<div class='guide"+this.randId+"Line"+uniqueIndex+" guideText' style='top:" + (marginTop - 16) + "px;left:" + (this.width - left + 4) + "px;'>(" + x + ", "  + y + ")</div>";
                graphHTML += "<div class='data data"+this.randId+" d"+this.randId+"data"+index+"' "; if (this.valueGuides) { graphHTML += "onMouseOver=lineOver(" + uniqueIndex + ","+this.randId+") onMouseOut=lineOut(" + uniqueIndex + ","+this.randId+") onClick=showLine(" + uniqueIndex + ","+this.randId+")";} graphHTML += " style='" + (this.animate && this.connected ? "display:none;visibility:hidden;" : "") +"left:" + (this.width - left - 3) + "px;margin-top:" + (marginTop - 3) + "px;background:" + this.barColorSet[index] + "'>";

                  if(this.connected && cIndex < this.points[index].length - 1){
                    let angleHeight = (this.height - (((y - this.minYValue) / (this.maxYValue - this.minYValue)) * this.height)) - (this.height - (((this.points[index][parseInt(cIndex) + 1].y - this.minYValue) / (this.maxYValue - this.minYValue)) * this.height));
                    let angleWidth = (this.width - (((x - this.minXValue) / (this.maxXValue - this.minXValue)) * this.width)) - (this.width - (((this.points[index][parseInt(cIndex) + 1].x - this.minXValue) / (this.maxXValue - this.minXValue)) * this.width));
                    let slopeInRadians = Math.atan(angleHeight / angleWidth);
                    let slopeInDegrees =  90 - ((slopeInRadians * 180) / Math.PI);
                    let lineLength = Math.sqrt((angleHeight * angleHeight) + (angleWidth * angleWidth));
                    graphHTML += "<div class='line l"+this.randId+"line" + index+ " ' style='height:" + (this.animate ? 0 : lineLength) + "px;max-height:" + lineLength + "px;background:" + this.barColorSet[index] + ";transform:rotate("+slopeInDegrees+"deg);'></div>";
                  }
                graphHTML += "</div>";
                uniqueIndex++;
              }
              this.maxIndex = parseInt(index) + 1;
            }
            if(this.trendLine){
              graphHTML += this.generateTrendLine();
            }
            graphHTML += "</div>";

            //LABELS
            bottomOfGraphHTML += "<div class='bottomLabelsContainer'>";
            var left = 80;
              for (let i = 0; i <= this.xIntervals; i ++) {
                if(i == 0) {
                  bottomOfGraphHTML += "<div class='xInterval' style=left:"+ (left - 5) +"px;width:" + (this.width / this.xIntervals) * 2 + "px;>" + parseFloat((i * ((this.maxXValue - this.minXValue) / this.xIntervals)) + this.minXValue).toFixed(2).replace(".00","") + "</div>";
                  continue;
                }
                bottomOfGraphHTML += "<div class='xInterval' style=left:"+left+"px;width:" + (this.width / this.xIntervals) * 2 + "px;text-align:center;>" + parseFloat((i * ((this.maxXValue - this.minXValue) / this.xIntervals)) + this.minXValue).toFixed(2).replace(".00","") + "</div>";
                left += (this.width / this.xIntervals);
              }
            if (this.xLabel != "") {
              bottomOfGraphHTML += "<div class='xLabel' style='width:" + this.width+ "px;margin-top:25px;'>" + this.xLabel + "</div>";
            }
            bottomOfGraphHTML += "</div>";
            bottomOfGraphHTML += "</div>";

            if (this.animate == "all") {
              setTimeout( () => {
                let size = 0;
                for(let data in this.data) {
                  size++;
                }
                for (let i = 0; i <= size; i++) {
                  animateOneByOneStart(0, i, "all", this.randId);
                }
              },0);
            }

            if (this.animate == "onebyone") {
              setTimeout(() => {
                animateOneByOneStart(0, 0, "onebyone", this.randId);
              },0);
            }
              return `${topOfGraphHTML}${intervalsHTML}${zoomHTML}${intervalGuidesHTML}${graphHTML}${bottomOfGraphHTML}`;
          }

          generateTrendLine() {
            let trendLine = "";
            let xSum = 0;
            let ySum = 0;

            this.allpoints.forEach( (coords) => {
              xSum += coords.x;
              ySum += coords.y;
            });

            let xAvg = xSum / this.allpoints.length;
            let yAvg = ySum / this.allpoints.length;
            let avgLeft = (this.width - (((xAvg - this.minXValue) / (this.maxXValue - this.minXValue)) * this.width)) - 4;
            let avgMarginTop = (this.height - (((yAvg - this.minYValue) / (this.maxYValue - this.minYValue)) * this.height)) - 4;

            let  minYCoord = (yAvg * this.allpoints[0].x) / xAvg;
            let  maxYCoord = (yAvg * this.allpoints[this.allpoints.length - 1].x) / xAvg;
            if (this.allpoints[0].y > this.allpoints[this.allpoints.length -1 ].y) {
              minYCoord = (yAvg * this.allpoints[this.allpoints.length - 1].x) / xAvg;
              maxYCoord = (yAvg * this.allpoints[0].x) / xAvg;
            }

            let minLeft = (this.width - (((this.allpoints[0].x - this.minXValue) / (this.maxXValue - this.minXValue)) * this.width)) - 4;
            let minMarginTop = (this.height - (((minYCoord - this.minYValue) / (this.maxYValue - this.minYValue)) * this.height)) - 4;

            let maxLeft = (this.width - (((this.allpoints[this.allpoints.length - 1].x - this.minXValue) / (this.maxXValue - this.minXValue)) * this.width)) - 4;
            let maxMarginTop = (this.height - (((maxYCoord - this.minYValue) / (this.maxYValue - this.minYValue)) * this.height)) - 4;

            let angleHeight = (this.height - (((minYCoord - this.minYValue) / (this.maxYValue - this.minYValue)) * this.height)) - (this.height - (((maxYCoord - this.minYValue) / (this.maxYValue - this.minYValue)) * this.height));
            let angleWidth = (this.width - (((this.allpoints[0].x - this.minXValue) / (this.maxXValue - this.minXValue)) * this.width)) - (this.width - (((this.allpoints[this.allpoints.length - 1].x  - this.minXValue) / (this.maxXValue - this.minXValue)) * this.width));
            let slopeInRadians = Math.atan(angleHeight / angleWidth);
            let slopeInDegrees =  90 - ((slopeInRadians * 180) / Math.PI);
            let lineLength = Math.sqrt((angleHeight * angleHeight) + (angleWidth * angleWidth));
            trendLine += "<div class='trendLine l"+this.randId+"line" + this.maxIndex + " d"+this.randId+"data"+this.maxIndex+"' style='height:" + (this.animate == "all" || this.animate == "onebyone" ? 0 : lineLength) + "px;max-height:" + lineLength + "px;bottom:"+ ((this.height - minMarginTop) - 4) + "px;right:" + (minLeft+4) + "px;transform:rotate("+slopeInDegrees+"deg);'></div>";
            return trendLine;
          }

          zoom(x1, x2, y1, y2) {
            let minX = ((x1 / this.width) * (this.maxXValue - this.minXValue)) + this.minXValue;
            let maxX = ((x2 / this.width) * (this.maxXValue - this.minXValue)) + this.minXValue;
            let maxY = (((this.height - y1) / this.height) * (this.maxYValue - this.minYValue)) + this.minYValue;
            let minY = (((this.height - y2) / this.height) * (this.maxYValue - this.minYValue)) + this.minYValue;
            if (this.animate) {
               this.isAnimated = true;
               this.animate = false;
            }
            if (!this.origMaxXValue) {
              this.origMinXValue = this.minXValue;
              this.origMaxXValue = this.maxXValue;
              this.origMinYValue = this.minYValue;
              this.origMaxYValue = this.maxYValue;
            }
            this.minXValue = minX;
            this.maxXValue = maxX;
            this.minYValue = minY;
            this.maxYValue = maxY;
            this.zoomed = true;
            this.container.innerHTML = this.generateScatterPlot();
            document.getElementById("graphDataDiv"+this.randId).addEventListener("mousedown", (e) => { startZoom(e, this.randId) }, false);
            document.getElementById("graphDataDiv"+this.randId).addEventListener("mousemove", (e) => { setZoom(e, this.randId) }, false);
            document.getElementById("graphDataDiv"+this.randId).addEventListener("mouseup", () => { zoom(this, this.randId) }, false);
            document.getElementById(this.randId+"zoomOut").addEventListener("mousedown", () => { zoomOut(this) }, false);
            if (this.isAnimated) {
              this.animate = true;
            }
          }

          zoomOut() {
            if (this.animate) {
               this.isAnimated = true;
               this.animate = false;
            }

            this.minXValue = this.origMinXValue;
            this.maxXValue = this.origMaxXValue ;
            this.minYValue = this.origMinYValue;
            this.maxYValue = this.origMaxYValue;
            this.zoomed = false;
            this.container.innerHTML = this.generateScatterPlot();
            document.getElementById("graphDataDiv"+this.randId).addEventListener("mousedown", (e) => { startZoom(e, this.randId) }, false);
            document.getElementById("graphDataDiv"+this.randId).addEventListener("mousemove", (e) => { setZoom(e, this.randId) }, false);
            document.getElementById("graphDataDiv"+this.randId).addEventListener("mouseup", () => { zoom(this, this.randId) }, false);
            if (this.isAnimated) {
              this.animate = true;
            }
          }

      }

      class Point {
        constructor(coords) {
          this.x = coords.x;
          this.y = coords.y;
        }
      }

      var startZoom = (e, randId) => {
        let bounds = document.getElementById("graphDataDiv" + randId).getBoundingClientRect();
        let graphLeft = Math.abs(parseInt(e.clientX  - bounds.left) );
        let graphTop = Math.abs(parseInt(e.clientY - bounds.top) );
        let startZoom = document.getElementById(randId+"startZoom");
        if (graphLeft < 0) {
          graphLeft = 0;
        }
        if (graphTop < 0) {
          graphTop = 0;
        }
        startZoom.style.left = graphLeft + "px";
        startZoom.style.top =  graphTop + "px";
        startZoom.style.display = "block";

        document.getElementById(randId+"leftBounds").style.height = "0px";
        document.getElementById(randId+"rightBounds").style.height = "0px";
        document.getElementById(randId+"topBounds").style.width = "0px";
        document.getElementById(randId+"bottomBounds").style.width = "0px";

      }

      var setZoom = (e, randId) => {
        if(document.getElementById(randId+"startZoom").style.display == "block") {
          let graph = document.getElementById("graphDataDiv" + randId);
          let bounds = graph.getBoundingClientRect();
          let graphLeft = Math.abs(parseInt(e.clientX  - bounds.left) );
          let graphTop = Math.abs(parseInt(e.clientY - bounds.top) );
          let graphHeight = graph.style.height.replace("px","");
          let graphWidth = graph.style.width.replace("px","");
          let setZoom = document.getElementById(randId+"setZoom");
          if (graphLeft < 0) {
            graphLeft = 0;
          }
          if (graphTop < 0) {
            graphTop = 0;
          }
          setZoom.style.left = graphLeft + "px";
          setZoom.style.top =  graphTop + "px";
          setZoom.style.display = "block";

          let startZoom = document.getElementById(randId+"startZoom");
          let leftBounds = document.getElementById(randId+"leftBounds");
          let rightBounds = document.getElementById(randId+"rightBounds");
          let topBounds = document.getElementById(randId+"topBounds");
          let bottomBounds = document.getElementById(randId+"bottomBounds");
          let startTop = startZoom.style.top.replace("px","");
          let setTop = setZoom.style.top.replace("px","");
          let startLeft= startZoom.style.left.replace("px","");
          let setLeft = setZoom.style.left.replace("px","");
          document.getElementById(randId+"topBoundsBox").style.height = Math.min(startTop, setTop) + 4 + "px";
          document.getElementById(randId+"bottomBoundsBox").style.height = Math.min(graphHeight - startTop, graphHeight - setTop) - 4 + "px";
          document.getElementById(randId+"leftBoundsBox").style.width = Math.min(startLeft, setLeft) + 4 + "px";
          document.getElementById(randId+"rightBoundsBox").style.width = Math.min(graphWidth - startLeft, graphWidth - setLeft) - 4 + "px";
          document.getElementById(randId+"leftBoundsBox").style.top = document.getElementById(randId+"topBoundsBox").style.height;
          document.getElementById(randId+"rightBoundsBox").style.top = document.getElementById(randId+"topBoundsBox").style.height;
          leftBounds.style.height = Math.abs(parseInt(startTop - setTop)) + 6 + "px";
          document.getElementById(randId+"leftBoundsBox").style.height = Math.abs(parseInt(startTop - setTop)) + "px";
          document.getElementById(randId+"rightBoundsBox").style.height = Math.abs(parseInt(startTop - setTop)) + "px";
          if(parseInt(startTop - setTop) < 0) {
            leftBounds.style.top = "";
            leftBounds.style.bottom = "0px";
            document.getElementById(randId+"innerLeftSquare").style.top = "";
            document.getElementById(randId+"innerLeftSquare").style.bottom = "-4px";
          } else {
            leftBounds.style.top = "0px";
            leftBounds.style.bottom = "";
            document.getElementById(randId+"innerLeftSquare").style.top = "-4px";
            document.getElementById(randId+"innerLeftSquare").style.bottom = "";
          }
          rightBounds.style.height = Math.abs(parseInt(startTop - setTop)) + 6 + "px";
          if(parseInt(startTop - setTop) < 0) {
            rightBounds.style.top = "0px";
            rightBounds.style.bottom = "";
            document.getElementById(randId+"innerRightSquare").style.top = "-4px";
            document.getElementById(randId+"innerRightSquare").style.bottom = "0px";
          } else {
            rightBounds.style.top = "";
            rightBounds.style.bottom = "0px";
            document.getElementById(randId+"innerRightSquare").style.top = "";
            document.getElementById(randId+"innerRightSquare").style.bottom = "-4px";
          }
          topBounds.style.width = Math.abs(parseInt(startLeft - setLeft)) + 1 + "px";
          if(parseInt(startLeft - setLeft) < 0) {
            topBounds.style.left = "0px";
            topBounds.style.right= "";
          } else {
            topBounds.style.left = "";
            topBounds.style.right = "0px";
          }
          bottomBounds.style.width = Math.abs(parseInt(startLeft - setLeft)) + "px";
          if(parseInt(startLeft - setLeft) < 0) {
            bottomBounds.style.left = "";
            bottomBounds.style.right= "0px";
          } else {
            bottomBounds.style.left = "0px";
            bottomBounds.style.right = "";
          }

        }
      }

      var zoom = (obj,randId)  => {
        let data = document.querySelectorAll(".data" + randId);
        if(document.getElementById(randId+"setZoom").style.display == "block" && data[data.length-1].style.visibility!= "hidden") {
          let xValues = [];
          let yValues = [];
          xValues.push(document.getElementById(randId+"startZoom").style.left.replace("px",""));
          xValues.push(document.getElementById(randId+"setZoom").style.left.replace("px",""));
          yValues.push(document.getElementById(randId+"startZoom").style.top.replace("px",""));
          yValues.push(document.getElementById(randId+"setZoom").style.top.replace("px",""));
          xValues.sort(function(a,b) { return a - b });
          yValues.sort(function(a,b) { return a - b });
          obj.zoom(xValues[0],xValues[1],yValues[0],yValues[1]);
        }
        document.getElementById(randId+"setZoom").style.display = "none";
        document.getElementById(randId+"startZoom").style.display = "none";
        document.getElementById(randId+"topBoundsBox").style.height = "0px";
        document.getElementById(randId+"bottomBoundsBox").style.height = "0px";
        document.getElementById(randId+"leftBoundsBox").style.width = "0px";
        document.getElementById(randId+"rightBoundsBox").style.width = "0px";
      }

      function zoomOut(obj){
        obj.zoomOut();
      }

      var animateOneByOneStart = (i, lineIndex, type, randId) => {
        var line = document.querySelectorAll(".l"+randId+"line" + lineIndex)[i];
        document.querySelectorAll(".d"+randId+"data" + lineIndex)[i].style.display = "block";
        document.querySelectorAll(".d"+randId+"data" + lineIndex)[i].style.visibility = "visible";
        if (line) {
          var height = parseInt(line.style.maxHeight.replace("px",""));
          animateLine(line, 0, height, i, lineIndex, type, randId);
        } else if (type != "all") {
            animateOneByOneStart(0, lineIndex + 1, "onebyone", randId);
        }
      }

      var animateLine = (line, currentHeight, targetHeight, i, lineIndex, type, randId) => {
        if (currentHeight >= targetHeight) {
          if (i != undefined) {
            animateOneByOneStart(i + 1, lineIndex, type, randId);
          }
          return;
        }
        line.style.height = (currentHeight + (targetHeight/500) * 5) + "px";
        setTimeout(function(){
          animateLine(line, currentHeight + (targetHeight/500 * 5), targetHeight, i, lineIndex, type, randId);
        },1);
      }

      var showLine = (i,randId) =>  {
        document.querySelectorAll(".guide"+randId+"Line"+i).forEach( el => {
          el.style.display="block";
        });
      }
      var lineOver = (i,randId) => {
        document.querySelectorAll(".guide"+randId+"Line"+i).forEach( el => {
          el.style.display="block";
        });
      }
      var lineOut = (i,randId) => {
        document.querySelectorAll(".guide"+randId+"Line"+i).forEach( el => {
          el.style.display="none";
        });
      }

      var showData = (i, randId) => {
        let data = document.querySelectorAll(".data"+randId);
        if (data[data.length-1].style.visibility=="hidden") {
          return;
        }
        data.forEach( el => {
          el.style.display = "none";
        });
        data = document.querySelectorAll(".d"+randId+"data" + i);
        data.forEach( el => {
          el.style.display = "block";
        });
      }

      var showAllData = (randId) => {
        let data = document.querySelectorAll(".data"+randId);
        if (data[data.length-1].style.visibility=="hidden") {
          return;
        }
        data.forEach( el => {
          el.style.display = "block";
        });
      }

    </script>
  </head>
  <body>
    <div id="container"></div>
  </body>
  <script>
    var graphProperties = {
      container: document.getElementById("container"),
      type: "scatter",
      title: "My Graph",
      minYValue: 0,
      maxYValue: 1,
      minXValue: 0,
      maxXValue: 1,
      height: 400,
      width: 500,
      xIntervals: 10,
      yIntervals: 10,
      xLabel: "Customers",
      yLabel: "Dollars",
      data: {
        Jonathan: {
          color: "red",
          points: [
            new Point({x: .1 , y:.2}),
            new Point({x: .2, y:.1}),
            new Point({x: .3, y:.14}),
            new Point({x: .4, y:.7}),
            new Point({x: .5, y:.5})
          ]
        },
        Josh: {
          color: "blue",
          points: [
            new Point({x: .2 , y:.56}),
            new Point({x: .4, y:.72}),
            new Point({x: .6, y:.40}),
            new Point({x: .8, y:.110}),
            new Point({x: .9, y:.190})
          ]
        }
      },
      intervalGuides: true,
      valueGuides: true,
      showValues: true,
      graphKey: true,
      trendLine: true,
      disableZoom: false,
      graphKeyTitle: "People",
      connected: true,
      animate: "all"
    }
    var myGraph = new Graph(graphProperties);
  </script>
</html>
